#include <openssl/err.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <openssl/ssl.h>

#include "ieee1609dot2.h"
#include "ssl_local.h"
#include "statem/statem_local.h"
#include "internal/endian.h"

#define _1609DOT2_VSN 0x1609

static unsigned char key_der[] = {
		0x30, 0x82, 0x09, 0x2b, 0x02, 0x01, 0x00, 0x02, 0x82, 0x02, 0x01, 0x00,
		0xc2, 0x68, 0xbc, 0x46, 0xa0, 0x21, 0xb6, 0x44, 0xd0, 0x52, 0x2b, 0xa4,
		0xb4, 0x40, 0xc2, 0xd9, 0x0e, 0xf6, 0xfa, 0x89, 0x32, 0x47, 0x2e, 0x85,
		0xd4, 0x8c, 0x49, 0x40, 0xd9, 0x2c, 0x06, 0x7a, 0xf3, 0x8b, 0x35, 0x9b,
		0x70, 0x8d, 0xd1, 0xf7, 0x89, 0x28, 0x9b, 0xb1, 0x71, 0x63, 0xe3, 0x21,
		0xae, 0x3c, 0x3b, 0xef, 0x17, 0xb8, 0x7e, 0x73, 0x76, 0x8c, 0xf0, 0x20,
		0x23, 0xb4, 0x2b, 0x96, 0x09, 0xda, 0x9f, 0xec, 0xaf, 0x56, 0x79, 0x29,
		0x49, 0xe6, 0xed, 0x2f, 0x95, 0x18, 0xc5, 0xfe, 0x01, 0xef, 0xa7, 0x36,
		0x8e, 0xda, 0x13, 0xe2, 0x60, 0x14, 0x5d, 0x25, 0xff, 0x86, 0x0e, 0x59,
		0x17, 0x42, 0xd2, 0x9f, 0xcc, 0x6d, 0xc6, 0xb0, 0x03, 0xb7, 0xc7, 0x78,
		0x1d, 0x5b, 0x94, 0x5d, 0x94, 0xd5, 0xa8, 0x02, 0x6b, 0x25, 0x7d, 0xd5,
		0xc6, 0x92, 0x78, 0x49, 0xe6, 0xaa, 0x6d, 0x84, 0xf7, 0xbe, 0xca, 0x1f,
		0x1b, 0x57, 0x75, 0x32, 0x8b, 0x3c, 0x17, 0xb8, 0xc9, 0x72, 0x59, 0x17,
		0xa5, 0x1d, 0x29, 0x53, 0xdf, 0x9e, 0x82, 0xc7, 0xbc, 0x3a, 0x17, 0x74,
		0x26, 0x35, 0xc2, 0x52, 0x92, 0x11, 0x41, 0x25, 0x65, 0xe6, 0x86, 0x53,
		0x2a, 0xbe, 0x6c, 0x5c, 0xa9, 0xa6, 0x98, 0xfc, 0xc9, 0xdf, 0x03, 0xb1,
		0x53, 0xc4, 0x02, 0x44, 0xf3, 0x65, 0x6b, 0xa0, 0x07, 0x9b, 0x31, 0x31,
		0x14, 0xf6, 0x59, 0x80, 0x1f, 0xa6, 0x4f, 0xf6, 0x2e, 0x0a, 0x08, 0xbd,
		0x39, 0x5b, 0xb4, 0xcb, 0xee, 0x6a, 0x45, 0xe8, 0x09, 0x01, 0x10, 0xcc,
		0x35, 0xdc, 0x87, 0xaf, 0x15, 0xf2, 0xd8, 0x59, 0xee, 0x9c, 0x39, 0x13,
		0x72, 0xed, 0x5b, 0xcd, 0xc8, 0xb0, 0xd7, 0x42, 0x7e, 0xc2, 0x57, 0x31,
		0x42, 0xba, 0xe9, 0x57, 0x40, 0x43, 0x1a, 0x7e, 0x6b, 0x74, 0x22, 0x9b,
		0xf3, 0x04, 0xe2, 0xdb, 0xe7, 0xcb, 0x7c, 0x3d, 0x9a, 0x3a, 0x90, 0x9c,
		0x58, 0x81, 0xc9, 0x2f, 0xbe, 0x3a, 0xea, 0x24, 0x70, 0x29, 0x8f, 0xff,
		0x97, 0x0f, 0x89, 0xd0, 0x9e, 0x8f, 0xc9, 0x5e, 0xd7, 0x2f, 0x0a, 0x8d,
		0x67, 0x38, 0xf4, 0x93, 0xac, 0xe2, 0x2d, 0xcc, 0xf9, 0x6f, 0x15, 0x37,
		0xcf, 0xa2, 0xe5, 0x23, 0x24, 0x7d, 0xcc, 0xf0, 0x42, 0x34, 0xa0, 0xcd,
		0x4f, 0xdd, 0x6b, 0xd8, 0x83, 0xd3, 0xb1, 0xe3, 0xf0, 0xe5, 0xcd, 0x29,
		0x95, 0x71, 0x08, 0x46, 0x49, 0x9e, 0x22, 0x11, 0x76, 0xe4, 0xa3, 0x0e,
		0x50, 0x13, 0x50, 0x64, 0xc7, 0xd8, 0xdd, 0x2c, 0x7c, 0xc6, 0x6b, 0x94,
		0x5b, 0x36, 0x0a, 0xac, 0xb1, 0x65, 0x77, 0x93, 0x0a, 0x09, 0x44, 0x92,
		0x94, 0x6c, 0x4d, 0x8d, 0xa9, 0x18, 0x70, 0x0f, 0xfc, 0x5a, 0x3b, 0x63,
		0x2d, 0xcd, 0xf4, 0xc8, 0x07, 0x89, 0x87, 0x5e, 0x3e, 0x68, 0x7a, 0x59,
		0xf6, 0xfc, 0x7e, 0xf7, 0xa5, 0x3c, 0x02, 0xd7, 0xc8, 0xa4, 0xb6, 0x76,
		0x55, 0xa5, 0xc6, 0x18, 0x6b, 0xc0, 0xa6, 0x25, 0x90, 0xb4, 0xa0, 0x9d,
		0x1a, 0x54, 0xa4, 0x1a, 0xab, 0x26, 0xad, 0x1b, 0x9e, 0x9a, 0x34, 0xc8,
		0x1a, 0xe6, 0x2e, 0x4b, 0x46, 0x28, 0x28, 0x4c, 0x60, 0xe5, 0x9b, 0x02,
		0xa1, 0x3c, 0x21, 0xd2, 0x81, 0x12, 0x3e, 0xd8, 0xf5, 0x27, 0xfb, 0x5b,
		0x03, 0x67, 0x4c, 0xa6, 0x33, 0xc8, 0x63, 0x5f, 0x8b, 0x60, 0x31, 0xaf,
		0x4b, 0x49, 0x7e, 0x66, 0x0d, 0xfa, 0x7c, 0xe6, 0xfa, 0xf5, 0x9a, 0xf0,
		0x13, 0x5a, 0x7a, 0x22, 0xb7, 0xa7, 0x71, 0x84, 0x96, 0xf4, 0x90, 0x9a,
		0x6d, 0x7d, 0xf8, 0xe6, 0xc3, 0x64, 0xee, 0x93, 0x8f, 0x06, 0x8e, 0x5a,
		0x0a, 0x03, 0xa5, 0xd7, 0x3f, 0xe4, 0x6b, 0x93, 0x0d, 0xa0, 0x82, 0xbd,
		0x9b, 0x67, 0x70, 0xf1, 0x3d, 0xa1, 0x41, 0x8b, 0x02, 0x03, 0x01, 0x00,
		0x01, 0x02, 0x82, 0x02, 0x01, 0x00, 0xaa, 0x9f, 0x1d, 0x4e, 0xa6, 0xcf,
		0xaf, 0x96, 0x69, 0x77, 0x14, 0x92, 0xb3, 0x18, 0x7b, 0x69, 0xe1, 0x36,
		0x65, 0xdf, 0xef, 0x5e, 0x85, 0xb8, 0x33, 0x39, 0x04, 0x39, 0x83, 0xe0,
		0x9d, 0xb7, 0x5e, 0xf3, 0xf8, 0x92, 0x79, 0x90, 0x1e, 0x8d, 0x2f, 0xb5,
		0x92, 0x1f, 0x83, 0xb2, 0xf4, 0xee, 0xe4, 0x6a, 0x3c, 0xf7, 0xb4, 0x4b,
		0xd9, 0xbf, 0x20, 0x76, 0xc5, 0x70, 0x8f, 0xa5, 0x5a, 0xf3, 0x8d, 0xa6,
		0x70, 0xe1, 0x5b, 0x69, 0x7b, 0x60, 0xff, 0x59, 0x4b, 0x25, 0x8d, 0xa7,
		0x76, 0x6d, 0x5d, 0xe9, 0xa5, 0x49, 0xbe, 0xca, 0x2a, 0xd5, 0x6d, 0x19,
		0xb2, 0x3e, 0xdd, 0x2a, 0x1c, 0x81, 0x98, 0x66, 0xaf, 0x50, 0x4c, 0x2c,
		0xb4, 0x4a, 0x5a, 0x98, 0xfa, 0xd9, 0xb2, 0x7a, 0x63, 0x96, 0x56, 0x3f,
		0xc5, 0xfa, 0x89, 0x6b, 0x18, 0x2b, 0x7c, 0xe1, 0xa3, 0xec, 0xc8, 0x23,
		0x1f, 0x87, 0xa9, 0x9f, 0xaa, 0xe8, 0xee, 0x28, 0x2d, 0xd5, 0xb4, 0x59,
		0x83, 0x40, 0x4c, 0x9c, 0xad, 0x10, 0x91, 0x7b, 0x2c, 0x80, 0x4e, 0x2c,
		0x61, 0xff, 0x46, 0x75, 0x7d, 0x8c, 0x14, 0xd4, 0xed, 0xbd, 0x66, 0x30,
		0xfa, 0x8a, 0x06, 0x0a, 0xf2, 0x2d, 0x1f, 0xc0, 0x8c, 0x7e, 0x2e, 0xee,
		0xe6, 0x2a, 0x46, 0x4a, 0x12, 0x85, 0x99, 0x4c, 0xd7, 0xe9, 0x07, 0xed,
		0x25, 0x2e, 0x08, 0x3e, 0xee, 0x47, 0x73, 0x6c, 0x5a, 0x54, 0x96, 0x72,
		0x72, 0x8f, 0x4f, 0x0c, 0xc3, 0x6a, 0xbf, 0x62, 0x7b, 0x24, 0xd8, 0x14,
		0x31, 0x52, 0x5a, 0x44, 0xb3, 0x27, 0x66, 0xc6, 0x2b, 0xd7, 0x40, 0x5e,
		0x27, 0xff, 0x95, 0xe9, 0x4a, 0x36, 0x85, 0x91, 0x48, 0x17, 0x2d, 0x61,
		0xf7, 0x2a, 0x86, 0xf1, 0xad, 0x70, 0xb0, 0x6e, 0x36, 0xc8, 0xba, 0xbf,
		0xaa, 0x0a, 0xf5, 0xe7, 0xb1, 0x50, 0x49, 0x53, 0x2a, 0x7d, 0xe9, 0xf7,
		0x5f, 0x3a, 0x93, 0xbf, 0x7a, 0xdf, 0x04, 0xf7, 0x27, 0xa0, 0xbe, 0x80,
		0x3d, 0x04, 0x4c, 0xc2, 0x28, 0xa4, 0x83, 0x23, 0x10, 0x56, 0x9a, 0x1e,
		0xb6, 0x58, 0xe7, 0x02, 0xe3, 0x36, 0xf2, 0xd3, 0xd2, 0x08, 0x31, 0x37,
		0x32, 0x48, 0x90, 0xc9, 0x1f, 0xb2, 0x68, 0xad, 0xbb, 0x59, 0xb1, 0x43,
		0x80, 0x94, 0x3d, 0xfa, 0x46, 0x10, 0xcd, 0x7e, 0xbe, 0xc8, 0x6c, 0x99,
		0xd8, 0x86, 0xff, 0x61, 0x9b, 0x27, 0xaf, 0x96, 0x1f, 0x1f, 0x28, 0xdb,
		0xeb, 0xfa, 0xf6, 0x89, 0x90, 0x09, 0x96, 0xcb, 0xbc, 0xc2, 0x4f, 0x95,
		0xf9, 0xb8, 0x23, 0xdf, 0xb7, 0x3d, 0x5b, 0xdb, 0x6d, 0xb4, 0x67, 0x74,
		0x9c, 0x7e, 0xaf, 0x1b, 0x8c, 0xe5, 0x10, 0x4a, 0xf1, 0xa2, 0xcb, 0x5e,
		0x59, 0xef, 0x45, 0xd2, 0x27, 0xdd, 0x54, 0x92, 0x85, 0x99, 0xe1, 0xd6,
		0x04, 0x0f, 0xe0, 0xde, 0x1c, 0xb9, 0x3e, 0x49, 0xea, 0x5c, 0xda, 0x09,
		0x2b, 0x70, 0x1f, 0x2f, 0xec, 0x40, 0x6a, 0xd4, 0x98, 0x21, 0x8b, 0x18,
		0xa4, 0x37, 0x1f, 0x6a, 0xa3, 0x42, 0x92, 0x79, 0x19, 0x23, 0x03, 0x63,
		0xee, 0x25, 0x69, 0x7c, 0x2f, 0xe4, 0xda, 0xc7, 0xd5, 0x14, 0x1e, 0x39,
		0x51, 0x25, 0xea, 0x1a, 0x22, 0xd6, 0x88, 0xb9, 0xc3, 0x0c, 0xe4, 0x44,
		0x70, 0x5f, 0x6f, 0xe5, 0x20, 0xb5, 0xc3, 0x3a, 0x74, 0x70, 0xe2, 0x9a,
		0x4e, 0xa0, 0x31, 0x75, 0x5e, 0x23, 0xe4, 0xdf, 0xe4, 0xce, 0xae, 0x24,
		0xc9, 0x11, 0x51, 0x81, 0xcc, 0x2f, 0x80, 0x9b, 0x90, 0x9e, 0x38, 0x86,
		0xed, 0xc5, 0xeb, 0x90, 0x2d, 0x50, 0xf0, 0x71, 0x72, 0xa1, 0xaf, 0x29,
		0x42, 0xab, 0xcf, 0x33, 0xd5, 0x7d, 0x71, 0x05, 0x86, 0x80, 0x6d, 0x6b,
		0x40, 0xa7, 0x38, 0x73, 0xc1, 0x09, 0x75, 0x16, 0x01, 0x14, 0xf1, 0x8f,
		0x45, 0x71, 0x02, 0x82, 0x01, 0x01, 0x00, 0xe7, 0x04, 0xa1, 0xe5, 0x4c,
		0x99, 0xb2, 0xb6, 0xaa, 0xbf, 0xb1, 0x57, 0x5b, 0x20, 0xe3, 0xa4, 0xa7,
		0x60, 0x7a, 0xd8, 0x5d, 0xa8, 0x93, 0xa3, 0xd2, 0xaa, 0x24, 0xa7, 0x2a,
		0x31, 0x4f, 0x58, 0xea, 0xe3, 0x22, 0x5e, 0x66, 0xf2, 0xfe, 0x80, 0xa5,
		0x3c, 0x24, 0xd6, 0x0b, 0x11, 0x12, 0x02, 0x41, 0x46, 0x0e, 0x1a, 0x84,
		0x85, 0x06, 0xe6, 0x89, 0x14, 0xaa, 0xff, 0xbe, 0x34, 0x4e, 0x30, 0x34,
		0x2d, 0xc9, 0x92, 0x19, 0x19, 0x7f, 0xc5, 0x75, 0xbf, 0xb5, 0x1d, 0x40,
		0x5e, 0x2b, 0x89, 0xe9, 0x73, 0x3f, 0x9f, 0x88, 0xf0, 0x97, 0x64, 0xfb,
		0xdb, 0x84, 0xdf, 0x18, 0xc2, 0xad, 0x61, 0x07, 0xa0, 0xa0, 0x32, 0x70,
		0x1d, 0x91, 0xa0, 0xc7, 0xd9, 0xd7, 0xc9, 0xcc, 0x90, 0x2f, 0xbd, 0x0f,
		0x1f, 0x2d, 0x62, 0x9b, 0x2c, 0x37, 0x4b, 0xe1, 0x3b, 0x4a, 0xe6, 0x27,
		0xc0, 0x7d, 0x2e, 0x60, 0x78, 0x43, 0xbb, 0x20, 0x72, 0x5b, 0x3b, 0xc9,
		0x7b, 0x3f, 0x38, 0x15, 0x80, 0xec, 0x1b, 0xf7, 0x40, 0x22, 0x00, 0x48,
		0xfe, 0x34, 0x9e, 0x71, 0x57, 0x24, 0xba, 0xec, 0x58, 0xad, 0xb0, 0x9a,
		0xd4, 0x5a, 0x2f, 0x89, 0x47, 0x19, 0x6a, 0x6d, 0x0d, 0x1e, 0x30, 0x5f,
		0x74, 0x03, 0xee, 0x38, 0xfe, 0x7d, 0x12, 0x77, 0xd9, 0x54, 0x80, 0x60,
		0x82, 0x63, 0xcf, 0x77, 0x46, 0x77, 0x30, 0xa6, 0x7c, 0xe9, 0x8b, 0x80,
		0x46, 0xe7, 0xdc, 0xfa, 0x75, 0x5f, 0xa7, 0xac, 0x00, 0x18, 0xba, 0xed,
		0xe9, 0xb4, 0xa3, 0xf5, 0x48, 0x4a, 0x77, 0x61, 0x1d, 0xa3, 0x27, 0x29,
		0x42, 0x56, 0xb3, 0xf7, 0xf1, 0x68, 0x5f, 0x9d, 0x9b, 0x74, 0x73, 0xce,
		0x4d, 0x17, 0x30, 0x11, 0xff, 0x55, 0x97, 0x29, 0x23, 0x69, 0x9f, 0x27,
		0x89, 0xd9, 0x4e, 0x78, 0xc0, 0xe9, 0x9b, 0x3d, 0x07, 0x7a, 0x4d, 0x02,
		0x82, 0x01, 0x01, 0x00, 0xd7, 0x6e, 0xa4, 0x5b, 0x70, 0xee, 0x85, 0x70,
		0xad, 0x66, 0xbe, 0x20, 0x7a, 0xf4, 0x16, 0xcd, 0xee, 0x9f, 0xbc, 0xcf,
		0xa6, 0xd2, 0x73, 0x47, 0x6d, 0x8b, 0x25, 0xe8, 0x55, 0xa4, 0x1b, 0xfe,
		0x0f, 0xb4, 0xc0, 0xa0, 0xa1, 0x1d, 0xa0, 0x5d, 0xe9, 0xe3, 0x96, 0x9c,
		0x9b, 0x01, 0xf2, 0xdb, 0x2f, 0x84, 0x41, 0x4c, 0x1e, 0xce, 0xff, 0x2d,
		0xbb, 0x98, 0xd1, 0x31, 0x98, 0x30, 0x16, 0x95, 0x88, 0xdb, 0x0a, 0x0e,
		0xb3, 0x76, 0x14, 0x89, 0x71, 0xc4, 0xd2, 0x2b, 0x6f, 0x9b, 0xcf, 0x6c,
		0x83, 0xa7, 0xff, 0xb0, 0x2c, 0x98, 0x74, 0x93, 0x05, 0x94, 0x04, 0x5a,
		0xb7, 0x87, 0x84, 0xff, 0x4c, 0xe7, 0x3e, 0xfe, 0xa1, 0xe7, 0x83, 0xe7,
		0xec, 0x07, 0xba, 0xc0, 0xdb, 0x6e, 0xa7, 0x4a, 0x3b, 0x1f, 0x33, 0xff,
		0x13, 0x4b, 0xad, 0xda, 0x1d, 0xf4, 0xd6, 0x99, 0xa0, 0x1d, 0x39, 0x6d,
		0x84, 0x6e, 0xab, 0x3d, 0xc7, 0xec, 0x56, 0x69, 0x97, 0xe2, 0xc7, 0xef,
		0x2e, 0x9c, 0xbe, 0x0b, 0x25, 0x66, 0xe4, 0x44, 0x07, 0x1b, 0x2a, 0xad,
		0xba, 0x72, 0x99, 0x6d, 0xaa, 0x3f, 0x2c, 0x9a, 0xf3, 0x87, 0x80, 0x4f,
		0xcb, 0xaa, 0x59, 0xff, 0xc8, 0xba, 0xb1, 0x18, 0xe2, 0x70, 0x79, 0x28,
		0x99, 0x0e, 0x3e, 0x65, 0xa7, 0x11, 0x5a, 0xa1, 0x80, 0x44, 0xc6, 0xa1,
		0x62, 0x18, 0x18, 0x0e, 0x01, 0x1b, 0x94, 0x7c, 0x7a, 0x73, 0x4b, 0x38,
		0xed, 0xac, 0xcf, 0xed, 0x3c, 0x7e, 0xf9, 0x83, 0x5a, 0xdb, 0xe5, 0x14,
		0xb8, 0x32, 0x62, 0xf8, 0x4e, 0x03, 0xaf, 0x59, 0x1f, 0x83, 0x6a, 0xf8,
		0x35, 0xbf, 0xf7, 0x5f, 0x1b, 0xfb, 0x71, 0x37, 0xbb, 0xf4, 0x6f, 0x6c,
		0x3d, 0x18, 0xf9, 0xe3, 0x3a, 0x67, 0xf7, 0x09, 0x8d, 0x26, 0x10, 0x56,
		0xf5, 0x4a, 0x61, 0x02, 0xb0, 0x95, 0x67, 0x37, 0x02, 0x82, 0x01, 0x01,
		0x00, 0x9c, 0x15, 0x66, 0x28, 0xdd, 0x8b, 0x4e, 0xd2, 0xda, 0x24, 0xaf,
		0xf6, 0x1c, 0x8c, 0xe9, 0x21, 0x5b, 0x30, 0xf5, 0x6e, 0xf0, 0x40, 0xb0,
		0x97, 0xd4, 0x02, 0xbe, 0xc6, 0xee, 0xdb, 0xe8, 0x07, 0x64, 0x93, 0xd7,
		0xa9, 0xbe, 0x96, 0xd8, 0xdb, 0x24, 0x48, 0xb1, 0x7e, 0xa8, 0x75, 0x7d,
		0x1c, 0x66, 0xeb, 0xa5, 0x25, 0xc7, 0x79, 0x75, 0x83, 0x17, 0x05, 0x0e,
		0xcf, 0xc1, 0xbb, 0xe7, 0x43, 0xec, 0x4d, 0x2f, 0x4e, 0x75, 0x84, 0xe3,
		0xee, 0x0e, 0xb3, 0x5a, 0xf4, 0x0b, 0x84, 0x54, 0x98, 0x56, 0x51, 0x56,
		0xa0, 0x3c, 0x4e, 0x89, 0x8b, 0x62, 0x1b, 0x1b, 0xf7, 0xfb, 0xeb, 0xb4,
		0x66, 0xc5, 0x57, 0x82, 0x44, 0xf1, 0xb9, 0x18, 0xa6, 0x6f, 0xc0, 0xc0,
		0x6a, 0x08, 0xbb, 0x36, 0x75, 0xdf, 0x1c, 0xaa, 0x76, 0x5f, 0xef, 0x0c,
		0xe1, 0x48, 0xa8, 0xdd, 0xdf, 0x08, 0xe6, 0xa5, 0xed, 0x4a, 0xa2, 0x96,
		0xe8, 0x7c, 0x70, 0xa7, 0x31, 0x8a, 0xdc, 0xa9, 0x87, 0x04, 0x08, 0x59,
		0xfe, 0x3f, 0x1c, 0x66, 0x9c, 0x98, 0xb4, 0x9f, 0xea, 0x99, 0x1b, 0x4e,
		0xa6, 0xb8, 0x7e, 0xe5, 0xc3, 0x57, 0xa8, 0xb7, 0xd2, 0x3c, 0x46, 0xfc,
		0x66, 0x0a, 0x8d, 0xfd, 0x62, 0xa3, 0x6b, 0x68, 0x28, 0x70, 0xfb, 0x88,
		0x97, 0x8c, 0xc0, 0x1a, 0xb6, 0xad, 0xfe, 0x0a, 0xdf, 0xa6, 0x6f, 0xc6,
		0xa1, 0xe9, 0x2a, 0xa6, 0x44, 0x69, 0x83, 0xfe, 0xae, 0x2f, 0xce, 0x53,
		0xb5, 0x9e, 0xa1, 0x66, 0x14, 0x0e, 0x20, 0x83, 0xba, 0xef, 0x43, 0x4b,
		0x84, 0xc2, 0xe9, 0xda, 0x4c, 0xe0, 0x34, 0x81, 0x0e, 0x11, 0x2c, 0x5a,
		0xdf, 0x97, 0x45, 0xeb, 0xf5, 0x3e, 0x62, 0x99, 0x93, 0x11, 0xe5, 0xd8,
		0xf7, 0x4b, 0x85, 0x30, 0x9c, 0xa6, 0x83, 0x1d, 0x7e, 0x46, 0x59, 0xd8,
		0xbb, 0xd9, 0x0d, 0x0f, 0x55, 0x02, 0x82, 0x01, 0x01, 0x00, 0x88, 0x2b,
		0xee, 0x85, 0xc2, 0x27, 0x72, 0x7f, 0x5b, 0x8b, 0xd2, 0xe7, 0xd2, 0xf0,
		0x10, 0xae, 0x10, 0x84, 0x35, 0xa3, 0x87, 0xce, 0x04, 0x82, 0x04, 0xb2,
		0xec, 0xbe, 0x23, 0xcb, 0xfc, 0xc9, 0xa5, 0x81, 0xda, 0x34, 0x6e, 0x42,
		0xbc, 0xc8, 0x3f, 0xfb, 0xd4, 0x8a, 0x9e, 0xcc, 0x27, 0x86, 0xf6, 0x4d,
		0x01, 0xbd, 0x2c, 0xc8, 0x28, 0xb1, 0xee, 0x9f, 0x54, 0xb3, 0xa5, 0x7f,
		0xd7, 0xf6, 0xa3, 0x2f, 0xd8, 0xf6, 0x9b, 0xe7, 0x2a, 0x6a, 0x0a, 0x58,
		0x9f, 0x84, 0x47, 0x22, 0xd4, 0x84, 0xc1, 0xdf, 0x62, 0x16, 0x28, 0xca,
		0x20, 0xfd, 0x81, 0x8c, 0x23, 0x08, 0x78, 0x73, 0x97, 0xd4, 0x8b, 0xf6,
		0xab, 0x71, 0xe6, 0x42, 0xe1, 0xb4, 0xaa, 0x13, 0xe4, 0xae, 0xdc, 0xc4,
		0xdf, 0xc7, 0x63, 0x01, 0x81, 0x2b, 0x5d, 0x35, 0xfb, 0xe9, 0x20, 0x00,
		0x4f, 0xd9, 0x81, 0x44, 0x97, 0xb5, 0x2a, 0xfd, 0x8d, 0x0e, 0x1b, 0x1d,
		0xbf, 0x2d, 0x35, 0x8d, 0x6a, 0x55, 0x3c, 0x40, 0x65, 0x3b, 0xc4, 0x63,
		0x7a, 0x2b, 0xa9, 0xd6, 0x39, 0x2e, 0xe0, 0xe8, 0x69, 0x24, 0xd1, 0x74,
		0xe7, 0x2b, 0xf6, 0x7d, 0x12, 0xd4, 0xdd, 0x66, 0x8b, 0x46, 0xcb, 0xc9,
		0x7e, 0x01, 0xbd, 0xb7, 0xdc, 0x4d, 0x96, 0x19, 0x53, 0xc5, 0x8b, 0x49,
		0xc3, 0xe0, 0xcb, 0xa4, 0x2d, 0x6d, 0x7b, 0x04, 0xc1, 0xc7, 0xb0, 0x59,
		0x8f, 0x8c, 0xf3, 0x15, 0x87, 0x59, 0xaf, 0x9a, 0x09, 0x3f, 0xea, 0x7a,
		0x54, 0x1a, 0xfc, 0x46, 0x7c, 0x51, 0x91, 0x70, 0x7f, 0xf0, 0x75, 0xd7,
		0x8c, 0x71, 0xa8, 0x22, 0xb8, 0x6d, 0xb6, 0x03, 0xe6, 0x47, 0xde, 0xf7,
		0x1b, 0x84, 0x60, 0x30, 0xcc, 0x71, 0x3d, 0x59, 0x59, 0x32, 0x91, 0x0b,
		0x80, 0x32, 0x30, 0x5e, 0xfb, 0xfb, 0x0b, 0x46, 0xfd, 0x74, 0xe6, 0xcb,
		0x39, 0x17, 0x02, 0x82, 0x01, 0x01, 0x00, 0xd0, 0x32, 0xf9, 0x50, 0x96,
		0x7a, 0x6a, 0x1d, 0x89, 0xf7, 0x27, 0x34, 0x41, 0xe7, 0x62, 0x7b, 0x38,
		0x3f, 0xf1, 0x9d, 0x40, 0x9f, 0xab, 0x4e, 0xf5, 0x18, 0x05, 0x91, 0x9f,
		0x7a, 0x82, 0xca, 0xcb, 0x8a, 0xe8, 0xfd, 0xa7, 0xbc, 0xee, 0x25, 0xce,
		0x7b, 0xd8, 0xad, 0xac, 0x6f, 0x92, 0xa2, 0x1e, 0x81, 0x42, 0x1f, 0xea,
		0xe8, 0x15, 0x3f, 0x1f, 0xed, 0xc1, 0x6e, 0x31, 0xec, 0xd4, 0xce, 0x55,
		0x1a, 0x5f, 0x75, 0xcf, 0x7b, 0x31, 0xde, 0x3d, 0x12, 0x85, 0x76, 0x7f,
		0x45, 0x98, 0x3e, 0x12, 0x92, 0xd6, 0x11, 0x49, 0x0f, 0x0b, 0x87, 0x52,
		0xaa, 0x53, 0xd9, 0x04, 0x8c, 0xda, 0x22, 0xdd, 0x31, 0xed, 0xc8, 0x6b,
		0x45, 0xc9, 0xa4, 0x06, 0x4d, 0xc5, 0x7c, 0x85, 0x73, 0x61, 0x7b, 0xec,
		0x58, 0x80, 0x59, 0x71, 0xed, 0x7b, 0xff, 0x43, 0x2c, 0xa3, 0x38, 0x8d,
		0x8e, 0x18, 0x67, 0x3f, 0x1f, 0x01, 0x40, 0x9d, 0xe4, 0xcb, 0x22, 0xa4,
		0x07, 0x1f, 0x76, 0x26, 0x6e, 0xad, 0x27, 0x37, 0x33, 0xce, 0xf9, 0xe2,
		0x82, 0x14, 0xbf, 0x7d, 0xc1, 0xd9, 0xa5, 0xb4, 0xef, 0x8e, 0x51, 0x48,
		0x93, 0x7c, 0x9e, 0x18, 0xed, 0x2a, 0xc8, 0x50, 0xdd, 0x9c, 0x4a, 0x16,
		0xb1, 0xd0, 0x62, 0xd0, 0xe7, 0xcd, 0xc9, 0x43, 0x18, 0x84, 0xdf, 0x65,
		0xaf, 0x88, 0xe8, 0x97, 0xec, 0xcc, 0x21, 0x45, 0x23, 0x92, 0x7a, 0x8e,
		0xf4, 0x58, 0x1c, 0xbd, 0x43, 0xf9, 0xbe, 0x16, 0x0f, 0xb3, 0x38, 0x94,
		0x91, 0x03, 0x21, 0xab, 0x71, 0x2c, 0xf6, 0xdf, 0x89, 0xd8, 0x5a, 0xef,
		0xea, 0x8a, 0x6f, 0x4a, 0xe9, 0x59, 0x9b, 0x53, 0x70, 0xa8, 0x3e, 0x88,
		0x3e, 0x78, 0x4d, 0x6d, 0x2b, 0x28, 0x48, 0x4c, 0xa2, 0x7b, 0xf9, 0x52,
		0x66, 0x3e, 0x51, 0x40, 0xbe, 0x70, 0xfd, 0xe1, 0x43, 0xf6, 0x3c
};
static unsigned int key_der_len = 2351;

static unsigned char X509_cert_der[] = {
  0x30, 0x82, 0x05, 0x67, 0x30, 0x82, 0x03, 0x4f, 0x02, 0x14, 0x51, 0x36,
  0xa8, 0xca, 0xae, 0xd8, 0xf6, 0x9d, 0x20, 0x3b, 0xd7, 0x64, 0xb8, 0xcb,
  0xd6, 0x91, 0x63, 0x0a, 0x1c, 0x5b, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86,
  0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x30, 0x70, 0x31,
  0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53,
  0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x02, 0x56,
  0x41, 0x31, 0x11, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x04, 0x07, 0x0c, 0x08,
  0x53, 0x6f, 0x6d, 0x65, 0x43, 0x69, 0x74, 0x79, 0x31, 0x12, 0x30, 0x10,
  0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x09, 0x4d, 0x79, 0x43, 0x6f, 0x6d,
  0x70, 0x61, 0x6e, 0x79, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04,
  0x0b, 0x0c, 0x0a, 0x4d, 0x79, 0x44, 0x69, 0x76, 0x69, 0x73, 0x69, 0x6f,
  0x6e, 0x31, 0x18, 0x30, 0x16, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x0f,
  0x77, 0x77, 0x77, 0x2e, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x6e, 0x79, 0x2e,
  0x63, 0x6f, 0x6d, 0x30, 0x1e, 0x17, 0x0d, 0x32, 0x30, 0x31, 0x31, 0x32,
  0x34, 0x30, 0x37, 0x34, 0x30, 0x32, 0x32, 0x5a, 0x17, 0x0d, 0x32, 0x31,
  0x31, 0x31, 0x32, 0x34, 0x30, 0x37, 0x34, 0x30, 0x32, 0x32, 0x5a, 0x30,
  0x70, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02,
  0x55, 0x53, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c,
  0x02, 0x56, 0x41, 0x31, 0x11, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x04, 0x07,
  0x0c, 0x08, 0x53, 0x6f, 0x6d, 0x65, 0x43, 0x69, 0x74, 0x79, 0x31, 0x12,
  0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x09, 0x4d, 0x79, 0x43,
  0x6f, 0x6d, 0x70, 0x61, 0x6e, 0x79, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03,
  0x55, 0x04, 0x0b, 0x0c, 0x0a, 0x4d, 0x79, 0x44, 0x69, 0x76, 0x69, 0x73,
  0x69, 0x6f, 0x6e, 0x31, 0x18, 0x30, 0x16, 0x06, 0x03, 0x55, 0x04, 0x03,
  0x0c, 0x0f, 0x77, 0x77, 0x77, 0x2e, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x6e,
  0x79, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x82, 0x02, 0x22, 0x30, 0x0d, 0x06,
  0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00,
  0x03, 0x82, 0x02, 0x0f, 0x00, 0x30, 0x82, 0x02, 0x0a, 0x02, 0x82, 0x02,
  0x01, 0x00, 0xc2, 0x68, 0xbc, 0x46, 0xa0, 0x21, 0xb6, 0x44, 0xd0, 0x52,
  0x2b, 0xa4, 0xb4, 0x40, 0xc2, 0xd9, 0x0e, 0xf6, 0xfa, 0x89, 0x32, 0x47,
  0x2e, 0x85, 0xd4, 0x8c, 0x49, 0x40, 0xd9, 0x2c, 0x06, 0x7a, 0xf3, 0x8b,
  0x35, 0x9b, 0x70, 0x8d, 0xd1, 0xf7, 0x89, 0x28, 0x9b, 0xb1, 0x71, 0x63,
  0xe3, 0x21, 0xae, 0x3c, 0x3b, 0xef, 0x17, 0xb8, 0x7e, 0x73, 0x76, 0x8c,
  0xf0, 0x20, 0x23, 0xb4, 0x2b, 0x96, 0x09, 0xda, 0x9f, 0xec, 0xaf, 0x56,
  0x79, 0x29, 0x49, 0xe6, 0xed, 0x2f, 0x95, 0x18, 0xc5, 0xfe, 0x01, 0xef,
  0xa7, 0x36, 0x8e, 0xda, 0x13, 0xe2, 0x60, 0x14, 0x5d, 0x25, 0xff, 0x86,
  0x0e, 0x59, 0x17, 0x42, 0xd2, 0x9f, 0xcc, 0x6d, 0xc6, 0xb0, 0x03, 0xb7,
  0xc7, 0x78, 0x1d, 0x5b, 0x94, 0x5d, 0x94, 0xd5, 0xa8, 0x02, 0x6b, 0x25,
  0x7d, 0xd5, 0xc6, 0x92, 0x78, 0x49, 0xe6, 0xaa, 0x6d, 0x84, 0xf7, 0xbe,
  0xca, 0x1f, 0x1b, 0x57, 0x75, 0x32, 0x8b, 0x3c, 0x17, 0xb8, 0xc9, 0x72,
  0x59, 0x17, 0xa5, 0x1d, 0x29, 0x53, 0xdf, 0x9e, 0x82, 0xc7, 0xbc, 0x3a,
  0x17, 0x74, 0x26, 0x35, 0xc2, 0x52, 0x92, 0x11, 0x41, 0x25, 0x65, 0xe6,
  0x86, 0x53, 0x2a, 0xbe, 0x6c, 0x5c, 0xa9, 0xa6, 0x98, 0xfc, 0xc9, 0xdf,
  0x03, 0xb1, 0x53, 0xc4, 0x02, 0x44, 0xf3, 0x65, 0x6b, 0xa0, 0x07, 0x9b,
  0x31, 0x31, 0x14, 0xf6, 0x59, 0x80, 0x1f, 0xa6, 0x4f, 0xf6, 0x2e, 0x0a,
  0x08, 0xbd, 0x39, 0x5b, 0xb4, 0xcb, 0xee, 0x6a, 0x45, 0xe8, 0x09, 0x01,
  0x10, 0xcc, 0x35, 0xdc, 0x87, 0xaf, 0x15, 0xf2, 0xd8, 0x59, 0xee, 0x9c,
  0x39, 0x13, 0x72, 0xed, 0x5b, 0xcd, 0xc8, 0xb0, 0xd7, 0x42, 0x7e, 0xc2,
  0x57, 0x31, 0x42, 0xba, 0xe9, 0x57, 0x40, 0x43, 0x1a, 0x7e, 0x6b, 0x74,
  0x22, 0x9b, 0xf3, 0x04, 0xe2, 0xdb, 0xe7, 0xcb, 0x7c, 0x3d, 0x9a, 0x3a,
  0x90, 0x9c, 0x58, 0x81, 0xc9, 0x2f, 0xbe, 0x3a, 0xea, 0x24, 0x70, 0x29,
  0x8f, 0xff, 0x97, 0x0f, 0x89, 0xd0, 0x9e, 0x8f, 0xc9, 0x5e, 0xd7, 0x2f,
  0x0a, 0x8d, 0x67, 0x38, 0xf4, 0x93, 0xac, 0xe2, 0x2d, 0xcc, 0xf9, 0x6f,
  0x15, 0x37, 0xcf, 0xa2, 0xe5, 0x23, 0x24, 0x7d, 0xcc, 0xf0, 0x42, 0x34,
  0xa0, 0xcd, 0x4f, 0xdd, 0x6b, 0xd8, 0x83, 0xd3, 0xb1, 0xe3, 0xf0, 0xe5,
  0xcd, 0x29, 0x95, 0x71, 0x08, 0x46, 0x49, 0x9e, 0x22, 0x11, 0x76, 0xe4,
  0xa3, 0x0e, 0x50, 0x13, 0x50, 0x64, 0xc7, 0xd8, 0xdd, 0x2c, 0x7c, 0xc6,
  0x6b, 0x94, 0x5b, 0x36, 0x0a, 0xac, 0xb1, 0x65, 0x77, 0x93, 0x0a, 0x09,
  0x44, 0x92, 0x94, 0x6c, 0x4d, 0x8d, 0xa9, 0x18, 0x70, 0x0f, 0xfc, 0x5a,
  0x3b, 0x63, 0x2d, 0xcd, 0xf4, 0xc8, 0x07, 0x89, 0x87, 0x5e, 0x3e, 0x68,
  0x7a, 0x59, 0xf6, 0xfc, 0x7e, 0xf7, 0xa5, 0x3c, 0x02, 0xd7, 0xc8, 0xa4,
  0xb6, 0x76, 0x55, 0xa5, 0xc6, 0x18, 0x6b, 0xc0, 0xa6, 0x25, 0x90, 0xb4,
  0xa0, 0x9d, 0x1a, 0x54, 0xa4, 0x1a, 0xab, 0x26, 0xad, 0x1b, 0x9e, 0x9a,
  0x34, 0xc8, 0x1a, 0xe6, 0x2e, 0x4b, 0x46, 0x28, 0x28, 0x4c, 0x60, 0xe5,
  0x9b, 0x02, 0xa1, 0x3c, 0x21, 0xd2, 0x81, 0x12, 0x3e, 0xd8, 0xf5, 0x27,
  0xfb, 0x5b, 0x03, 0x67, 0x4c, 0xa6, 0x33, 0xc8, 0x63, 0x5f, 0x8b, 0x60,
  0x31, 0xaf, 0x4b, 0x49, 0x7e, 0x66, 0x0d, 0xfa, 0x7c, 0xe6, 0xfa, 0xf5,
  0x9a, 0xf0, 0x13, 0x5a, 0x7a, 0x22, 0xb7, 0xa7, 0x71, 0x84, 0x96, 0xf4,
  0x90, 0x9a, 0x6d, 0x7d, 0xf8, 0xe6, 0xc3, 0x64, 0xee, 0x93, 0x8f, 0x06,
  0x8e, 0x5a, 0x0a, 0x03, 0xa5, 0xd7, 0x3f, 0xe4, 0x6b, 0x93, 0x0d, 0xa0,
  0x82, 0xbd, 0x9b, 0x67, 0x70, 0xf1, 0x3d, 0xa1, 0x41, 0x8b, 0x02, 0x03,
  0x01, 0x00, 0x01, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,
  0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x03, 0x82, 0x02, 0x01, 0x00, 0x0b,
  0x85, 0x86, 0x7a, 0xb7, 0xaf, 0xc3, 0x77, 0xde, 0x90, 0x2c, 0x62, 0x62,
  0xc3, 0x54, 0x71, 0xc7, 0x8d, 0x83, 0x6f, 0x9e, 0x7b, 0x43, 0xc6, 0xdc,
  0x15, 0xb6, 0x09, 0xe5, 0x6b, 0x5e, 0x3b, 0x52, 0x53, 0x61, 0x20, 0x56,
  0x26, 0x03, 0x41, 0x35, 0x79, 0xa9, 0xa6, 0x8b, 0xf1, 0xac, 0xfe, 0x72,
  0xd3, 0x12, 0xab, 0x7c, 0x05, 0x5e, 0xea, 0xb2, 0x50, 0x21, 0xf3, 0xdc,
  0xae, 0xdf, 0x81, 0x07, 0x82, 0xa1, 0xcf, 0x00, 0x2a, 0xcf, 0x58, 0xba,
  0xd3, 0x7a, 0x02, 0x37, 0x56, 0x86, 0xee, 0x15, 0x8f, 0x35, 0xee, 0x44,
  0x21, 0x70, 0xf9, 0x18, 0xde, 0xeb, 0xad, 0xe6, 0xa1, 0xb5, 0x5b, 0x3d,
  0x18, 0x0e, 0x59, 0x73, 0x8c, 0x35, 0x96, 0x40, 0xbb, 0xea, 0xcc, 0x70,
  0x13, 0xad, 0xde, 0xf5, 0x53, 0xdc, 0x34, 0x2e, 0x26, 0xfe, 0xa9, 0xa2,
  0x44, 0x85, 0x26, 0x47, 0x14, 0xc5, 0xc0, 0x99, 0x01, 0x7d, 0xfd, 0x95,
  0x7f, 0x9e, 0x02, 0xe0, 0xad, 0x94, 0xc1, 0xb4, 0x3c, 0xa0, 0xb7, 0x4b,
  0x14, 0xe8, 0x29, 0x26, 0x42, 0xaf, 0x16, 0x3c, 0xf3, 0x9d, 0xa3, 0x5b,
  0xe5, 0x6e, 0xf3, 0x73, 0x2f, 0x49, 0x3e, 0xe6, 0x10, 0xc7, 0x64, 0xe8,
  0xd7, 0xbc, 0xa3, 0x4d, 0xb8, 0x4c, 0x83, 0x1c, 0xf5, 0xcd, 0x2a, 0xd5,
  0x79, 0x44, 0x31, 0x0a, 0x39, 0x3c, 0xf5, 0xd9, 0xc7, 0xb8, 0x51, 0x0f,
  0xc8, 0x22, 0xca, 0x81, 0x0e, 0x8c, 0xcb, 0x8b, 0xf1, 0xd4, 0xcf, 0x70,
  0xc0, 0x5c, 0x9c, 0x14, 0xcc, 0x23, 0xe6, 0x76, 0xb6, 0xaa, 0xe0, 0x07,
  0x86, 0x11, 0xcd, 0x1f, 0x71, 0xd3, 0xfc, 0x73, 0x3f, 0xf5, 0x52, 0x2c,
  0x28, 0xa8, 0xdd, 0xc6, 0xd1, 0x52, 0x73, 0x48, 0xf4, 0xe0, 0x21, 0xbc,
  0xc5, 0xdd, 0x75, 0x69, 0x5c, 0x76, 0xa5, 0x61, 0x60, 0x93, 0xc8, 0x99,
  0xf0, 0x6c, 0x74, 0x07, 0x3a, 0xf3, 0x87, 0x03, 0x37, 0x1d, 0x03, 0x1f,
  0x9a, 0xb3, 0x61, 0xb4, 0x8d, 0x24, 0xe2, 0x2e, 0x48, 0xf5, 0xa1, 0x7d,
  0x38, 0xc2, 0xe9, 0x0f, 0x66, 0xed, 0x94, 0xde, 0x15, 0x68, 0x26, 0x17,
  0x43, 0xdd, 0x8a, 0xf6, 0xc7, 0xbf, 0x7a, 0x1a, 0x18, 0xb3, 0x5a, 0x77,
  0x68, 0x7d, 0x43, 0xf8, 0xf9, 0xee, 0x21, 0xfc, 0x5a, 0x60, 0x2b, 0xdf,
  0x2b, 0x51, 0x10, 0x89, 0xbd, 0xe0, 0x95, 0x08, 0x67, 0x0f, 0x73, 0xaf,
  0x65, 0x1d, 0x37, 0xdd, 0xe3, 0xcb, 0x09, 0x58, 0x93, 0xab, 0xb4, 0x55,
  0x3f, 0x7f, 0x29, 0x9f, 0x63, 0x5a, 0xc1, 0x3f, 0xd8, 0xc5, 0x46, 0x69,
  0x29, 0x48, 0x25, 0x0d, 0x65, 0x92, 0x71, 0xce, 0x7c, 0x00, 0xf8, 0x14,
  0xfa, 0x07, 0xc8, 0xda, 0xf7, 0xce, 0x98, 0xde, 0xaa, 0x5b, 0x2f, 0x5b,
  0xc9, 0xac, 0xd2, 0x56, 0x12, 0xd4, 0xf1, 0x38, 0xdf, 0x0c, 0x2d, 0xf4,
  0xff, 0xe9, 0xba, 0x22, 0x2e, 0xee, 0xb1, 0xd6, 0x8d, 0x70, 0x8a, 0x9e,
  0x58, 0x1f, 0x86, 0xf5, 0x39, 0x75, 0xe9, 0xa3, 0xb6, 0x1e, 0xa5, 0xe2,
  0x8a, 0x17, 0xf7, 0xaa, 0x69, 0xad, 0x83, 0x10, 0x36, 0x69, 0xc0, 0x72,
  0xa9, 0x81, 0xd6, 0x46, 0x0f, 0x55, 0x75, 0x1d, 0x57, 0xe7, 0x9e, 0x96,
  0x93, 0xab, 0x46, 0xa6, 0xec, 0xe8, 0x74, 0xf8, 0xa7, 0x6b, 0xed, 0xf0,
  0xbc, 0xe6, 0xe1, 0x1b, 0x4f, 0xf4, 0x46, 0x54, 0x43, 0x6b, 0x75, 0x42,
  0x1b, 0xa3, 0x4d, 0xcd, 0x8e, 0x75, 0x72, 0x29, 0xd7, 0x51, 0x2c, 0xaa,
  0x94, 0x1d, 0x88, 0x66, 0x49, 0x15, 0x4b, 0x20, 0x40, 0xcf, 0x80, 0xdd,
  0xcc, 0xcd, 0x95, 0xea, 0xd9, 0x59, 0xd5, 0xc9, 0x75, 0x42, 0x1d, 0xec,
  0xdb, 0xd5, 0xce, 0x53, 0x4e, 0x18, 0x1f, 0x14, 0xcf, 0x4f, 0xd7, 0xa4,
  0x69, 0xab, 0x9d, 0x1c, 0xfc, 0xaa, 0x5f
};
static unsigned int X509_cert_der_len = 1387;

static unsigned char __1609dot2_at_cert[] = {
  0x80, 0x03, 0x00, 0x80, 0x91, 0x41, 0x1b, 0x36, 0x96, 0xf8, 0x6c, 0xc4,
  0x30, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xcc, 0x60, 0x64, 0x84,
  0x00, 0xc8, 0x00, 0x01, 0x08, 0x80, 0x01, 0x24, 0x81, 0x04, 0x03, 0x01,
  0xff, 0xfc, 0x80, 0x01, 0x25, 0x81, 0x05, 0x04, 0x01, 0xff, 0xff, 0xff,
  0x80, 0x01, 0x89, 0x81, 0x03, 0x02, 0x01, 0xe0, 0x80, 0x01, 0x8a, 0x81,
  0x03, 0x02, 0x01, 0xc0, 0x80, 0x01, 0x8b, 0x81, 0x07, 0x06, 0x01, 0xff,
  0xff, 0xff, 0xff, 0xf8, 0x80, 0x01, 0x8c, 0x81, 0x05, 0x04, 0x02, 0xff,
  0xff, 0xe0, 0x00, 0x01, 0x8d, 0x80, 0x02, 0x02, 0x7d, 0x81, 0x02, 0x01,
  0x01, 0x80, 0x80, 0x82, 0x64, 0x2b, 0x3e, 0x4f, 0x08, 0xe9, 0x7c, 0x4d,
  0x19, 0x22, 0x6b, 0x40, 0x30, 0x44, 0x8b, 0x0a, 0x7b, 0xbd, 0xc2, 0xd2,
  0x84, 0x20, 0x4c, 0xb6, 0x6b, 0xea, 0x21, 0xdd, 0x1d, 0x0e, 0x0f, 0xe5,
  0x80, 0x80, 0x35, 0x44, 0x83, 0xcb, 0xbe, 0x0f, 0x1c, 0x0c, 0xe0, 0x8d,
  0x82, 0x1f, 0xc6, 0x2a, 0xe9, 0x03, 0x4c, 0x82, 0xc7, 0xe8, 0x13, 0x69,
  0x7b, 0x79, 0xb8, 0x11, 0x18, 0x8a, 0x61, 0x2f, 0xa7, 0x24, 0x1f, 0x32,
  0x0e, 0x2c, 0xaa, 0x1b, 0xb3, 0x26, 0x1d, 0x1c, 0x6f, 0xed, 0x58, 0x5e,
  0x73, 0x3f, 0x41, 0x23, 0x1f, 0x9f, 0xc9, 0x72, 0x94, 0x6d, 0x5a, 0x9f,
  0x74, 0xa0, 0xf4, 0x83, 0x40, 0xcb
};
static unsigned int __1609dot2_at_cert_len = 198;

static unsigned char __1609dot2_at_cert_hash[8] = {
    0xF3, 0xCA, 0xFF, 0x29, 0xD3, 0x5E, 0x0C, 0x1C
};

// index in X509 struture ext data
// see engines/e_capi.c for usage
static int g_x509_1609_idx = -1;
static int g_ssl_1609_idx = -1;

// uint8_t -> type
// uint32_t -> length
#define HASHEDID8_LEN 8
#define MAX_SSP_LEN 100
#define SEC_ENT_MSG_HDR_LEN 5
#define SEC_ENT_MSG_TYPE_FAILURE 0x03
#define SEC_ENT_MSG_TYPE_GET_CERT 8
#define SEC_ENT_MSG_TYPE_TLS_VERIFY_CERTS 18
#define SEC_ENT_MSG_TYPE_TLS_SIGN_DATA 19
#define SEC_ENT_MSG_TYPE_TLS_VERIFY_DATA 20
#define SEC_ENT_MSG_TYPE_GET_AT 22

#define PSID_DEFAULT 36
#define SEC_ENT_ADDR_DEFAULT "127.0.0.1"
#define SEC_ENT_PORT_DEFAULT 3999

struct sec_ent_msg_st {
// set contents
    uint8_t msg_type;
    uint32_t len;
    uint8_t* data;
};

typedef struct sec_ent_msg_st SEC_ENT_MSG;

struct ssl_IEEE1609_st {
    // do we want to allow cert_type extensions?
    int RFC8902_support;

    RFC8902_CERT_TYPE srv;
    RFC8902_CERT_TYPE clnt;

    // psid to use when making cert verify
    uint64_t psid_this_side;
    uint64_t psid_other_side;

    // SSP mathing cert and PSID used by the other side
    size_t ssp_other_side_len;
    uint8_t ssp_other_side[MAX_SSP_LEN];

    // sec_ent connection info
    char sec_ent_addr[INET_ADDRSTRLEN];
    int sec_ent_port;
};

typedef struct ssl_IEEE1609_st SSL_IEEE1609;

struct IEEE1609_cert_st {
    int version;
    long cert_data_len;
    unsigned char *cert_data;
    int hashed_id_present;
    uint8_t hashedid8[HASHEDID8_LEN];
};

typedef struct IEEE1609_cert_st IEEE1609_CERT;

/* Not all platforms have htobe64(). */
static uint64_t be64(uint64_t host)
{
    uint64_t big;
    uint8_t *data_out = (uint8_t *)&big;
    uint8_t *data_in = (uint8_t *)&host;
    DECLARE_IS_ENDIAN;

    if (!IS_LITTLE_ENDIAN)
        return host;

    data_out[0] = data_in[7];
    data_out[1] = data_in[6];
    data_out[2] = data_in[5];
    data_out[3] = data_in[4];
    data_out[4] = data_in[3];
    data_out[5] = data_in[2];
    data_out[6] = data_in[1];
    data_out[7] = data_in[0];

    return big;
}

/* Not all platforms have be64toh(). */
static uint64_t h64(uint64_t big)
{
    return be64(big);
}

static SEC_ENT_MSG * SEC_ENT_MSG_new_from_type_allocate(uint8_t msg_type, size_t len)
{
    SEC_ENT_MSG * msg = NULL;

    msg = OPENSSL_malloc(sizeof(*msg));
    if (msg == NULL) {
        ERR_raise(ERR_LIB_SSL, ERR_R_MALLOC_FAILURE);
        return NULL;
    }
    msg->msg_type = msg_type;
    msg->len = len;
    if (msg->len == 0) {
        msg->data = NULL;
    } else {
        msg->data = OPENSSL_malloc(len);
        if (msg->data == NULL) {
            ERR_raise(ERR_LIB_SSL, ERR_R_MALLOC_FAILURE);
            OPENSSL_free(msg);
            return NULL;
        }
    }

    return msg;
}

static SEC_ENT_MSG * SEC_ENT_MSG_new_from_type_buffer(
        uint8_t msg_type, const unsigned char * data, size_t len)
{
    SEC_ENT_MSG * msg = NULL;

    msg = SEC_ENT_MSG_new_from_type_allocate(msg_type, len);
    if (msg && len != 0) {
        memcpy(msg->data, data, len);
    }

    return msg;
}

static void SEC_ENT_MSG_free(SEC_ENT_MSG * msg) {
    if (msg != NULL){
        if (msg->data != NULL) {
            OPENSSL_free(msg->data);
        }
        OPENSSL_free(msg);
    }
}

static SEC_ENT_MSG * SEC_ENT_MSG_new_from_recv_buffer(
        const unsigned char * data, size_t len)
{
    SEC_ENT_MSG * msg = NULL;

    msg = OPENSSL_malloc(sizeof(*msg));
    if (msg == NULL) {
        ERR_raise(ERR_LIB_SSL, ERR_R_MALLOC_FAILURE);
        return NULL;
    }
    if (len <= 5) { // There must be a header of the sec_ent msg
        ERR_raise(ERR_LIB_SSL, SSL_R_BAD_DATA);
        goto err;
    }
    msg->msg_type = data[0];
    memcpy(&msg->len, &data[1], sizeof(msg->len));
    msg->len = ntohl(msg->len);
    if (msg->len + 5 != len) {
        ERR_raise(ERR_LIB_SSL, SSL_R_BAD_DATA);
        goto err;
    }
    if (msg->len == 0) {
        msg->data = NULL;
    } else {
        msg->data = OPENSSL_malloc(msg->len);
        if (msg->data == NULL) {
            ERR_raise(ERR_LIB_SSL, ERR_R_MALLOC_FAILURE);
            goto err;
        }
        memcpy(msg->data, &data[SEC_ENT_MSG_HDR_LEN], msg->len);
    }

    return msg;
err:
    OPENSSL_free(msg);
    return NULL;
}

static SEC_ENT_MSG * SEC_ENT_MSG_new_TYPE_TLS_VERIFY_CERTS(
        const unsigned char * data, size_t len)
{
    return SEC_ENT_MSG_new_from_type_buffer(
            SEC_ENT_MSG_TYPE_TLS_VERIFY_CERTS,
            data, len);
}

static SEC_ENT_MSG * SEC_ENT_MSG_new_TYPE_TLS_SIGN_DATA(
        uint64_t psid, const unsigned char hashedid8[8],
        const unsigned char * input, size_t input_len)
{
    SEC_ENT_MSG * msg = NULL;
    uint64_t psid_tmp;

    msg = SEC_ENT_MSG_new_from_type_allocate(
            SEC_ENT_MSG_TYPE_TLS_SIGN_DATA,
            sizeof(uint64_t) + HASHEDID8_LEN + input_len);
    if (msg == NULL) {
        ERR_raise(ERR_LIB_SSL, ERR_R_MALLOC_FAILURE);
        return NULL;
    }

    unsigned char * msg_pos = msg->data;
    psid_tmp = be64(psid);
    memcpy(msg_pos, &psid_tmp, sizeof(psid_tmp));
    msg_pos += sizeof(psid_tmp);
    memcpy(msg_pos, hashedid8, HASHEDID8_LEN);
    msg_pos += HASHEDID8_LEN;
    memcpy(msg_pos, input, input_len);

    return msg;
}

static SEC_ENT_MSG * SEC_ENT_MSG_new_TYPE_TLS_VERIFY_DATA(
        const unsigned char * hashedid8,
        const unsigned char * verify_data, size_t verify_data_len,
        const unsigned char * verify_input, size_t verify_input_len)
{
    SEC_ENT_MSG * msg = NULL;
    msg = SEC_ENT_MSG_new_from_type_allocate(
            SEC_ENT_MSG_TYPE_TLS_VERIFY_DATA,
            HASHEDID8_LEN + verify_data_len + verify_input_len);
    if (msg == NULL) {
        ERR_raise(ERR_LIB_SSL, ERR_R_MALLOC_FAILURE);
        return NULL;
    }
    unsigned char * msg_pos = msg->data;
    memcpy(msg_pos, hashedid8, HASHEDID8_LEN);
    msg_pos += HASHEDID8_LEN;
    memcpy(msg_pos, verify_data, verify_data_len);
    msg_pos += verify_data_len;
    memcpy(msg_pos, verify_input, verify_input_len);

    return msg;
}

static SEC_ENT_MSG * SEC_ENT_MSG_new_TYPE_GET_CERT(
        const unsigned char hashedid8[HASHEDID8_LEN])
{
    unsigned char msg_buff[9];
    unsigned char *msg_pos = msg_buff;
    memcpy(msg_pos, hashedid8, HASHEDID8_LEN);
    msg_pos += HASHEDID8_LEN;
    *msg_pos = 0x00;
    return SEC_ENT_MSG_new_from_type_buffer(
            SEC_ENT_MSG_TYPE_GET_CERT,
            msg_buff, HASHEDID8_LEN + 1);
}

static SEC_ENT_MSG * SEC_ENT_MSG_new_TYPE_GET_AT_CERT(void)
{
    return SEC_ENT_MSG_new_from_type_buffer(
            SEC_ENT_MSG_TYPE_GET_AT,
            NULL, 0);
}

static int SEC_ENT_MSG_get_send_buffer(SEC_ENT_MSG * msg,
        unsigned char ** data, size_t * len)
{
    if (*data != NULL || msg == NULL) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
        return 0;
    }
    uint32_t msg_len = msg->len;
    unsigned char * msg_buff = OPENSSL_malloc(msg_len + SEC_ENT_MSG_HDR_LEN);
    if (msg_buff == NULL) {
        ERR_raise(ERR_LIB_SSL, ERR_R_MALLOC_FAILURE);
        return 0;
    }
    // set out values;
    *len = msg_len + SEC_ENT_MSG_HDR_LEN;
    *data = msg_buff;
    // set buffer contents
    msg_buff[0] = msg->msg_type;
    msg_len = htonl(msg_len);
    memcpy(&msg_buff[1], &msg_len, sizeof(msg_len));
    memcpy(&msg_buff[SEC_ENT_MSG_HDR_LEN], msg->data, msg->len);

    return 1;
}

static void print_buffer(const unsigned char * data, size_t len) {
    fprintf(stderr, ">>> Buffer len[%zu] \n", len);
    for (int i = 0; i < (int)len; i++) {
        fprintf(stderr, "%02x ", ((unsigned char *) data)[i]);
        if ((i+1)%20 == 0) {
            fprintf(stderr, "\n");
        }
    }
    fprintf(stderr, "\n");
}

static IEEE1609_CERT * IEEE1609_CERT_new_from_buffer(const unsigned char ** data, long len) {
    IEEE1609_CERT * cert = NULL;

    cert = OPENSSL_malloc(sizeof(*cert));
    if (cert == NULL) {
        ERR_raise(ERR_LIB_SSL, ERR_R_MALLOC_FAILURE);
        return NULL;
    }
    cert->version = _1609DOT2_VSN;
    cert->cert_data_len = len;
    cert->hashed_id_present = 0;
    bzero(cert->hashedid8, sizeof(cert->hashedid8));
    cert->cert_data = OPENSSL_malloc(len);
    if (cert->cert_data == NULL) {
        ERR_raise(ERR_LIB_SSL, ERR_R_MALLOC_FAILURE);
        OPENSSL_free(cert);
        return NULL;
    }
    memcpy(cert->cert_data, *data, len);
    *data += len;

    return cert;
}

static IEEE1609_CERT * IEEE1609_CERT_dup(IEEE1609_CERT * cert) {
    IEEE1609_CERT * ret = NULL;

    if (cert != NULL) {
        ret = OPENSSL_memdup(cert, sizeof(*cert));
        if (ret == NULL) {
            ERR_raise(ERR_LIB_SSL, ERR_R_MALLOC_FAILURE);
            return NULL;
        }
        ret->cert_data = OPENSSL_memdup(ret->cert_data, ret->cert_data_len);
        if (ret == NULL) {
            ERR_raise(ERR_LIB_SSL, ERR_R_MALLOC_FAILURE);
            OPENSSL_free(ret);
            return NULL;
        }
    }

    return ret;
}

static void IEEE1609_CERT_free(IEEE1609_CERT * cert) {
    if (cert != NULL) {
        if (cert->cert_data != NULL) {
            OPENSSL_free(cert->cert_data);
        }
        OPENSSL_free(cert);
    }
}

static IEEE1609_CERT * IEEE1609_CERT_from_X509(X509 * x) {
    return X509_get_ex_data(x, g_x509_1609_idx);
}

// see ui_util.c
static void CRYPTO_EX_IEEE1609_CERT_new(void *parent, void *ptr, CRYPTO_EX_DATA *ad,
                           int idx, long argl, void *argp)
{
    /*
     * Do nothing, the data is allocated externally and assigned later with
     * CRYPTO_set_ex_data()
     */
}

static void CRYPTO_EX_IEEE1609_CERT_free(void *parent, void *ptr, CRYPTO_EX_DATA *ad,
                            int idx, long argl, void *argp)
{
    IEEE1609_CERT_free(ptr);
}

static int CRYPTO_EX_IEEE1609_CERT_dup(CRYPTO_EX_DATA *to, const CRYPTO_EX_DATA *from,
                          void **from_d, int idx, long argl, void *argp)
{
    void **pptr = from_d;
    if (*pptr != NULL) {
        *pptr = IEEE1609_CERT_dup(*pptr);
    }
    return 1;
}
static SSL_IEEE1609 * SSL_get_SSL_IEEE1609(SSL * s) {
    SSL_IEEE1609 * ieee1609_state = NULL;
    ieee1609_state = SSL_get_ex_data(s, g_ssl_1609_idx);
    return ieee1609_state;
}

RFC8902_CERT_TYPE * SSL_get_RFC8902_CERT_TYPE(SSL * s, int ext_idx) {
    SSL_IEEE1609 * ieee1609_state = NULL;
    ieee1609_state = SSL_get_SSL_IEEE1609(s);
    if (ext_idx == TLSEXT_TYPE_server_certificate_type) {
        return &ieee1609_state->srv;
    }
    if (ext_idx == TLSEXT_TYPE_client_certificate_type) {
        return &ieee1609_state->clnt;
    }
    ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
    return NULL;
}

// see ui_util.c
static void CRYPTO_EX_SSL_IEEE1609_new(void *parent, void *ptr, CRYPTO_EX_DATA *ad,
                           int idx, long argl, void *argp)
{
    SSL_IEEE1609 * data = NULL;

    data = OPENSSL_malloc(sizeof(SSL_IEEE1609));
    data->RFC8902_support = 0;
    data->srv.support = SSL_RFC8902_X509;
    data->srv.type_decided = -1;
    data->clnt.support = SSL_RFC8902_X509;
    data->clnt.type_decided = -1;

    data->psid_this_side = PSID_DEFAULT;
    data->psid_other_side = 0x00;
    data->ssp_other_side_len = 0;

    strncpy(data->sec_ent_addr, SEC_ENT_ADDR_DEFAULT, sizeof(data->sec_ent_addr));
    data->sec_ent_port = SEC_ENT_PORT_DEFAULT;

    CRYPTO_set_ex_data(ad, idx, data);
}

static void CRYPTO_EX_SSL_IEEE1609_free(void *parent, void *ptr, CRYPTO_EX_DATA *ad,
                            int idx, long argl, void *argp)
{
    if (ptr != NULL) {
        OPENSSL_free(ptr);
    }
    ptr = NULL;
}

static int CRYPTO_EX_SSL_IEEE1609_dup(CRYPTO_EX_DATA *to, const CRYPTO_EX_DATA *from,
                          void **from_d, int idx, long argl, void *argp)
{
    void **pptr = from_d;
    if (*pptr != NULL) {
        *pptr = OPENSSL_memdup(*pptr, sizeof(SSL_IEEE1609));
    }
    return 1;
}

// Are we using 1609 for client / server authentication
int SSL_is_using_1609_client(SSL *s)
{
    SSL_IEEE1609 * ieee1609_state = NULL;

    ieee1609_state = SSL_get_ex_data(s, g_ssl_1609_idx);
    return ieee1609_state->clnt.type_decided == CertificateType1609Dot2;
}

int SSL_is_using_1609_server(SSL *s)
{
    SSL_IEEE1609 * ieee1609_state = NULL;

    ieee1609_state = SSL_get_ex_data(s, g_ssl_1609_idx);
    return ieee1609_state->srv.type_decided == CertificateType1609Dot2;
}

int SSL_is_using_1609_this_side(SSL *s)
{
    if (SSL_is_server(s)) {
        return SSL_is_using_1609_server(s);
    } else {
        return SSL_is_using_1609_client(s);
    }
}

int SSL_is_using_1609_other_side(SSL *s)
{
    if (SSL_is_server(s)) {
        return SSL_is_using_1609_client(s);
    } else {
        return SSL_is_using_1609_server(s);
    }
}

void IEEE1609_TLS_init(void) {
    g_x509_1609_idx = X509_get_ex_new_index(0, NULL,
            CRYPTO_EX_IEEE1609_CERT_new,
            CRYPTO_EX_IEEE1609_CERT_dup,
            CRYPTO_EX_IEEE1609_CERT_free);
    g_ssl_1609_idx = SSL_get_ex_new_index(0, NULL,
            CRYPTO_EX_SSL_IEEE1609_new,
            CRYPTO_EX_SSL_IEEE1609_dup,
            CRYPTO_EX_SSL_IEEE1609_free);
}

void IEEE1609_TLS_free(void) {
}

static X509 * X509_new_fake_cert(X509 ** x) {
    X509 * cert = NULL;
	const unsigned char *p = X509_cert_der;

	cert = d2i_X509(x, &p, X509_cert_der_len);
	if (cert == NULL) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
        return NULL;
	}
    return cert;
}

int X509_is_IEEE1609_CERT(X509 * x) {
	if (x == NULL) {
		return 0;
	}
    if (IEEE1609_CERT_from_X509(x) != NULL) {
        return 1;
    }
	return 0;
}

X509 * X509_set_IEEE1609_CERT(X509 **x, const unsigned char **ppin, long length) {
	X509 * ptmpval = NULL;
    IEEE1609_CERT * cert = NULL;

    if (g_x509_1609_idx == -1) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
        return NULL;
    }

    if (x == NULL) {
        x = &ptmpval;
    }

    X509_new_fake_cert(x);
    if (*x == NULL) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
        return NULL;
    }

    cert = IEEE1609_CERT_new_from_buffer(ppin, length);
    if (cert == NULL) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
        goto err;
    }
    if (!X509_set_ex_data(*x, g_x509_1609_idx, cert)) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
        IEEE1609_CERT_free(cert);
        goto err;
    }

	return *x;
err:
    X509_free(*x);
    return NULL;
}

X509 * X509_new_IEEE1609_CERT(const unsigned char **ppin, long length) {
    return X509_set_IEEE1609_CERT(NULL, ppin, length);
}

int X509_append_IEEE1609_CERT_test(X509 * x) {
    IEEE1609_CERT * cert = NULL;
    const unsigned char *certstart = __1609dot2_at_cert;

    if (g_x509_1609_idx == -1) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
        return 0;
    }

    cert = IEEE1609_CERT_new_from_buffer(&certstart, __1609dot2_at_cert_len);
    if (cert == NULL) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
        return 0;
    }
    cert->hashed_id_present = 1;
    memcpy(cert->hashedid8, __1609dot2_at_cert_hash, sizeof(cert->hashedid8));
    if (!X509_set_ex_data(x, g_x509_1609_idx, cert)) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
        IEEE1609_CERT_free(cert);
        return 0;
    }
    return 1;
}

static int connect_server(SSL *s) {
    struct sockaddr_in servaddr;
    int sock_fd;
    SSL_IEEE1609 * ieee1609_state = NULL;

    sock_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (sock_fd == -1) {
        ERR_raise(ERR_LIB_SSL, SSL_R_SOCKET_ALLOC_FAILED);
        return -1;
    }
    bzero(&servaddr, sizeof(servaddr));

	ieee1609_state = SSL_get_SSL_IEEE1609(s);

    // assign IP, PORT
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = inet_addr(ieee1609_state->sec_ent_addr);
    servaddr.sin_port = htons(ieee1609_state->sec_ent_port);

    // connect the client socket to server socket
    if (connect(sock_fd, (struct sockaddr*)&servaddr, sizeof(servaddr)) != 0) {
        ERR_raise(ERR_LIB_SSL, SSL_R_SEC_ENT_CONNECT_FAILED);
        return -1;
    }

    return sock_fd;
}

static SEC_ENT_MSG * send_recv_server(int sock_fd,
        const unsigned char * out_data, size_t out_len,
        const unsigned char ** in_data, size_t *in_data_len)
{
    unsigned char buff[2048];
    SEC_ENT_MSG * reply = NULL;

    if (0) {
        print_buffer(buff, 0);
    }

#ifdef TLS_13_1609_DEBUG
    fprintf(stderr, ">>> send_recv_server - request\n");
    print_buffer(out_data, out_len);
#endif
    int write_len = write(sock_fd, out_data, out_len);
    if (write_len != (int)out_len) {
        ERR_raise_data(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR, "Unable to write to security-entity server");
        return NULL;
    }

    bzero(buff, sizeof(buff));
    int read_len = read(sock_fd, buff, sizeof(buff));
    if (read_len > (int)sizeof(buff)) {
        // TODO: this may be handled in the future
        ERR_raise_data(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR, "Unable to read from security-entity server");
        return NULL;
    }
#ifdef TLS_13_1609_DEBUG
    fprintf(stderr, ">>> send_recv_server - reply\n");
    print_buffer(buff, read_len);
#endif
    reply = SEC_ENT_MSG_new_from_recv_buffer(buff, read_len);
    if (reply == NULL) {
        ERR_raise_data(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR, "Unable to read a message from the buffer (len received %d)", read_len);
        return NULL;
    }
    if (reply->msg_type == SEC_ENT_MSG_TYPE_FAILURE) {
        ERR_raise(ERR_LIB_SSL, SSL_R_UNEXPECTED_MESSAGE);
        // if err string ends with \n change it to \0
        if (reply->data[reply->len - 1] == '\n') {
            reply->data[reply->len - 1] = '\0';
            ERR_add_error_data(1, reply->data);
        } else {
            char * reply_str = OPENSSL_malloc(reply->len + 1);
            if (reply_str != NULL) {
                memcpy(reply_str, reply->data, reply->len);
                reply_str[reply->len] = '\0';
                ERR_add_error_data(1, reply_str);
                OPENSSL_free(reply_str);
            }
        }
        SEC_ENT_MSG_free(reply);
        return NULL;
    }
    return reply;
}

static void disconnect_server(int sock_fd) {
    if (sock_fd > 0) {
        close(sock_fd);
        sock_fd = -1;
    }
}

static SEC_ENT_MSG * sec_ent_process(SSL *s, SEC_ENT_MSG * msg) {
    SEC_ENT_MSG * ret = NULL;
    unsigned char * msg_buff = NULL;
    size_t len;
    int sock_fd;

    sock_fd = connect_server(s);
    if (sock_fd < 0) {
        // ERR raised already
        return NULL;
    }
    if (!SEC_ENT_MSG_get_send_buffer(msg, &msg_buff, &len)) {
        // ERR raised already
        goto out;
    }
    ret = send_recv_server(sock_fd, msg_buff, len, NULL, NULL);
    if (ret == NULL) {
        // ERR raised already
        goto out;
    }

out:
    disconnect_server(sock_fd);
    OPENSSL_free(msg_buff);
    return ret;
}

int IEEE1609_CERT_verify(SSL *s, X509 * x) {
    IEEE1609_CERT * cert = NULL;
    SEC_ENT_MSG * msg = NULL;
    SEC_ENT_MSG * reply = NULL;
    int ret = 0;

    cert = X509_get_ex_data(x, g_x509_1609_idx);
    if (cert == NULL) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
        ret = 0;
        goto out;
    }

    msg = SEC_ENT_MSG_new_TYPE_TLS_VERIFY_CERTS(cert->cert_data, cert->cert_data_len);
    if (msg == NULL) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
        ret = 0;
        goto out;
    }
    reply = sec_ent_process(s, msg);
    if (reply == NULL) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
        ret = 0;
        goto out;
    }
    if (reply->msg_type != SEC_ENT_MSG_TYPE_TLS_VERIFY_CERTS) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
        ret = 0;
#ifdef TLS_13_1609_DEBUG
        fprintf(stderr,
            ">>> IEEE1609_CERT_verify something went wrong reply %d\n",
            reply->msg_type);
        print_buffer(reply->data, reply->len);
#endif
        goto out;
    }
    cert->hashed_id_present = 1;
    memcpy(cert->hashedid8, reply->data, sizeof(cert->hashedid8));
    ret = 1;

out:
    SEC_ENT_MSG_free(msg);
    SEC_ENT_MSG_free(reply);

	return ret;
}


int ssl_add_IEEE1609_CERT_to_wpacket(SSL *s, WPACKET *pkt, X509 *x, int chain)
{
    int len;
    unsigned char *outbytes;
    IEEE1609_CERT * cert_ptr = NULL;
    if (pkt == NULL) {
    	return 1;
    }

    cert_ptr = IEEE1609_CERT_from_X509(x);
    if (cert_ptr == NULL) {
        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);
        return 0;
    }
    len = cert_ptr->cert_data_len;
    outbytes = cert_ptr->cert_data;

    // based on
    if (len < 0) {
        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
        return 0;
    }

    if (!WPACKET_sub_memcpy_u24(pkt, outbytes, len)) {
        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
        return 0;
    }

    if (SSL_IS_TLS13(s)
        && !tls_construct_extensions(s, pkt, SSL_EXT_TLS1_3_CERTIFICATE, x,
        chain)) {
        /* SSLfatal() already called */
        return 0;
    }

    return 1;
}

int tls_construct_IEEE1609_CERT_cert_verify(SSL *s, WPACKET *pkt, X509* x,
    const unsigned char * input, size_t input_len)
{
    int ret = 0;
    IEEE1609_CERT * cert = NULL;
    SEC_ENT_MSG * msg = NULL;
    SEC_ENT_MSG * reply = NULL;

    cert = IEEE1609_CERT_from_X509(x);
    if (cert == NULL) {
        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
        goto err;
    }

#ifdef TLS_13_1609_DEBUG
    fprintf(stderr, ">>> VERIFY TBS DATA\n");
    print_buffer(input, input_len);
#endif

	SSL_IEEE1609 * ieee1609_state = NULL;
	ieee1609_state = SSL_get_SSL_IEEE1609(s);

    uint64_t psid = ieee1609_state->psid_this_side;
    msg = SEC_ENT_MSG_new_TYPE_TLS_SIGN_DATA(
        psid, cert->hashedid8, input, input_len);
    if (msg == NULL) {
        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
        goto err;
    }
    reply = sec_ent_process(s, msg);
    if (reply == NULL) {
        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
        goto err;
    }
    if (reply->msg_type != SEC_ENT_MSG_TYPE_TLS_SIGN_DATA) {
        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
#ifdef TLS_13_1609_DEBUG
        fprintf(stderr,
            ">>> tls_construct_IEEE1609_CERT_cert_verify something went wrong reply %d\n",
            reply->msg_type);
        print_buffer(reply->data, reply->len);
#endif
        goto err;
    }
#ifdef TLS_13_1609_DEBUG
    fprintf(stderr, ">>> tls_construct_IEEE1609_CERT_cert_verify %d\n", reply->msg_type);
    print_buffer(reply->data, reply->len);
#endif
    WPACKET_memcpy(pkt, reply->data, reply->len);
    goto ret;

ret:
    ret = 1;
    SEC_ENT_MSG_free(msg);
    SEC_ENT_MSG_free(reply);

    return ret;
err:
    ret = 0;
    SEC_ENT_MSG_free(msg);
    SEC_ENT_MSG_free(reply);

    return ret;
}

int tls_process_IEEE1609_CERT_cert_verify(SSL *s, X509 * x,
    const unsigned char * verify_input, size_t verify_input_len,
    const unsigned char * verify_data, size_t verify_data_len)
{
    IEEE1609_CERT * cert;
    SEC_ENT_MSG * msg = NULL;
    SEC_ENT_MSG * reply = NULL;

    cert = IEEE1609_CERT_from_X509(x);
    if (!cert) {
        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
        goto err;
    }

#ifdef TLS_13_1609_DEBUG
    fprintf(stderr, ">>> VERIFY INPUT DATA\n");
    print_buffer(verify_input, verify_input_len);

    fprintf(stderr, ">>> VERIFY DATA\n");
    print_buffer(verify_data, verify_data_len);
#endif

    msg = SEC_ENT_MSG_new_TYPE_TLS_VERIFY_DATA(
            cert->hashedid8,
            verify_data, verify_data_len,
            verify_input, verify_input_len);
    if (msg == NULL) {
        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
        goto err;
    }
    reply = sec_ent_process(s, msg);
    if (reply == NULL) {
        if (ERR_GET_REASON(ERR_peek_last_error()) == SSL_R_UNEXPECTED_MESSAGE) {
            SSLfatal(s, SSL_AD_INSUFFICIENT_SECURITY, SSL_R_CERTIFICATE_VERIFY_FAILED);    
        } else {
            SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
        }
        goto err;
    }
    if (reply->msg_type != SEC_ENT_MSG_TYPE_TLS_VERIFY_DATA) {
        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
#ifdef TLS_13_1609_DEBUG
        fprintf(stderr,
            ">>> tls_process_IEEE1609_CERT_cert_verify something went wrong reply %d\n",
            reply->msg_type);
        print_buffer(reply->data, reply->len);
#endif
        goto err;
    }

#ifdef TLS_13_1609_DEBUG
    fprintf(stderr,
        ">>> tls_process_IEEE1609_CERT_cert_verify %d\n",
        reply->msg_type);
    print_buffer(reply->data, reply->len);
#endif

    // set the PSID used
	SSL_IEEE1609 * ieee1609_state = NULL;

	ieee1609_state = SSL_get_ex_data(s, g_ssl_1609_idx);

    uint64_t psid;
    if (reply->len < sizeof(psid) || reply->len > sizeof(psid) + MAX_SSP_LEN) {
        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
        goto err;
    }
    memcpy(&psid, reply->data, sizeof(psid));
    psid = h64(psid);
	ieee1609_state->psid_other_side = psid;

    ieee1609_state->ssp_other_side_len = reply->len - sizeof(psid);
    if (ieee1609_state->ssp_other_side_len > 0 && ieee1609_state->ssp_other_side_len < MAX_SSP_LEN) {
        memcpy(&ieee1609_state->ssp_other_side, reply->data + sizeof(psid), ieee1609_state->ssp_other_side_len);
    }

    SEC_ENT_MSG_free(msg);
    SEC_ENT_MSG_free(reply);
    return 1;
err:
    SEC_ENT_MSG_free(msg);
    SEC_ENT_MSG_free(reply);
    return 0;
}

int SSL_use_1609_cert(SSL *s, const unsigned char * data, size_t len)
{
    const unsigned char *p = data;
    X509 *cert = NULL;
    int ret = 0;

    cert = X509_new_IEEE1609_CERT(&p, len);
    if (cert == NULL) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
        return 0;
    }
    // get hash for the certificate from buffer
    if (!IEEE1609_CERT_verify(s, cert)) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
        goto out;
    }
    ret = SSL_use_certificate(s, cert);
out:
    X509_free(cert);
    return ret;
}

int SSL_use_1609_PSID(SSL *s, uint64_t psid)
{
	SSL_IEEE1609 * ieee1609_state = NULL;

	ieee1609_state = SSL_get_ex_data(s, g_ssl_1609_idx);
	ieee1609_state->psid_this_side = psid;

    return 1;
}

int SSL_use_1609_cert_by_hash(SSL *s, const unsigned char hashedid[8])
{
    X509 *cert_x = NULL;
    IEEE1609_CERT * cert_1609 = NULL;
    int ret = 0;
    SEC_ENT_MSG * msg = NULL;
    SEC_ENT_MSG * reply = NULL;
    const unsigned char *p = NULL;

    msg = SEC_ENT_MSG_new_TYPE_GET_CERT(hashedid);
    if (msg == NULL) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
        goto out;
    }

    reply = sec_ent_process(s, msg);
    if (reply == NULL) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
        goto out;
    }

    if (reply->msg_type != SEC_ENT_MSG_TYPE_GET_CERT) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
#ifdef TLS_13_1609_DEBUG
        fprintf(stderr,
            ">>> SSL_use_1609_cert_by_hash something went wrong reply %d\n",
            reply->msg_type);
        print_buffer(reply->data, reply->len);
#endif
        goto out;
    }

    p = (const unsigned char *)reply->data;
    // last byte is presence of verification status - we didn't ask for it
    cert_x = X509_new_IEEE1609_CERT(&p, reply->len - 1);
    if (cert_x == NULL) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
        goto out;
    }

    cert_1609 = IEEE1609_CERT_from_X509(cert_x);
    if (cert_1609 == NULL) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
        goto out;
    }

    // set hashedid
    cert_1609->hashed_id_present = 1;
    memcpy(cert_1609->hashedid8, hashedid, HASHEDID8_LEN);

	// A hack - otherwise openssl thinks there is no key - so no cert_verify is generated
	// if (!SSL_use_RSAPrivateKey_ASN1(s, key_der, key_der_len)) {
    if (!SSL_use_PrivateKey_ASN1(EVP_PKEY_RSA, s, key_der, key_der_len)) {
		ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
		goto out;
	}

	ret = SSL_use_certificate(s, cert_x);

out:
    SEC_ENT_MSG_free(msg);
    SEC_ENT_MSG_free(reply);
    X509_free(cert_x);
    return ret;
}

int SSL_is_RFC8902_supported(SSL * s) 
{
    SSL_IEEE1609 * ieee1609_state = NULL;

    ieee1609_state = SSL_get_ex_data(s, g_ssl_1609_idx);
    return ieee1609_state->RFC8902_support;
}

static int sec_ent_initial_connection(SSL *s, int use_AT) 
{
    SEC_ENT_MSG * msg = NULL;
    SEC_ENT_MSG * reply = NULL;
    const unsigned char *p = NULL;
    int ret = 0;
    unsigned char hashedid[8];

    msg = SEC_ENT_MSG_new_TYPE_GET_AT_CERT();
    if (msg == NULL) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
        goto out;
    }

    reply = sec_ent_process(s, msg);
    if (reply == NULL) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
        goto out;
    }

    if (reply->msg_type != SEC_ENT_MSG_TYPE_GET_AT) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
#ifdef TLS_13_1609_DEBUG
        fprintf(stderr,
            ">>> sec_ent_test_connection something went wrong reply %d\n",
            reply->msg_type);
        print_buffer(reply->data, reply->len);
#endif
        goto out;
    }

    if (use_AT) {
        p = (const unsigned char *)reply->data;
        if (reply->len < sizeof(hashedid)) {
            ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
            goto out;
        }
        memcpy(hashedid, p, sizeof(hashedid));
        if (!SSL_use_1609_cert_by_hash(s, hashedid)) {
            ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
            goto out;
        }
    }
    ret = 1;

out:
    SEC_ENT_MSG_free(msg);
    SEC_ENT_MSG_free(reply);
    return ret;

}

int SSL_enable_RFC8902_support(SSL *s, int server_support, int client_support, int use_AT) {
    SSL_IEEE1609 * ieee1609_state = NULL;

    ieee1609_state = SSL_get_ex_data(s, g_ssl_1609_idx);
    ieee1609_state->RFC8902_support = 1;
    ieee1609_state->srv.support = server_support;
    ieee1609_state->clnt.support = client_support;

    // TODO: here we may be enabling AT usage even if "our" side doesn't support 1609 certs
    if (server_support & SSL_RFC8902_1609 || client_support & SSL_RFC8902_1609) {
        return sec_ent_initial_connection(s, use_AT);
    }

    return 1;
}

int SSL_set_1609_sec_ent_addr(SSL *s, int port, const char* addr) {
    SSL_IEEE1609 * ieee1609_state = NULL;

    ieee1609_state = SSL_get_ex_data(s, g_ssl_1609_idx);
    strncpy(ieee1609_state->sec_ent_addr, addr, sizeof(ieee1609_state->sec_ent_addr) - 1);
    ieee1609_state->sec_ent_port = port;

    return 1;
}

int SSL_get_1609_psid_received(SSL *s, uint64_t * const psid,
                               size_t * ssp_len, uint8_t ** ssp,
                               unsigned char hashedid[HASHEDID8_LEN]) {
	SSL_IEEE1609 * ieee1609_state = NULL;

	ieee1609_state = SSL_get_ex_data(s, g_ssl_1609_idx);
	if (ieee1609_state->psid_other_side == 0x00) {
		ERR_raise(ERR_LIB_SSL, SSL_R_NOT_1609_CERT);
		return 0;
	}

	*psid = ieee1609_state->psid_other_side;
    *ssp_len = ieee1609_state->ssp_other_side_len;
    if (*ssp != NULL) {
        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
        return 0;
    }
    if (*ssp_len != 0) {
        *ssp = malloc(*ssp_len);
        if (*ssp == NULL) {
            ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
            return 0; 
        }
        memcpy(*ssp, ieee1609_state->ssp_other_side, *ssp_len);
    }

	if (hashedid != NULL) {
		IEEE1609_CERT * cert = NULL;
		X509 * peer_x = NULL;

		peer_x = SSL_get0_peer_certificate(s);
		if (peer_x == NULL) {
			ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);
			goto err;
		}

		cert = IEEE1609_CERT_from_X509(peer_x);

		if (cert == NULL) {
			ERR_raise(ERR_LIB_SSL, SSL_R_NOT_1609_CERT);
			goto err;
		}

		memcpy(hashedid, cert->hashedid8, HASHEDID8_LEN);
	}
	return 1;
err:
    free(ssp);
    ssp = NULL;
    return 0;

}